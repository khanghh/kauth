package main

import (
	"fmt"
	"html/template"
	"os"
	"path"
	"reflect"
	"strings"
	"unicode"

	"github.com/khanghh/kauth/model"
	"gorm.io/gen"
)

const constantsFile = "constants.gen.go"
const constantTemplate = `
// Code generated by {{ .ScriptName }} DO NOT EDIT.

package {{ .PackageName }}

{{- range .Models }}
// {{.ModelName}} column names
  {{- range .Fields }}
const Col{{.ModelName}}{{.FieldName}} = "{{.ColumnName}}"
  {{- end }}
// {{.ModelName}} index names
  {{- range .Fields}}
    {{- if .IndexName }}
const Idx{{.ModelName}}{{.FieldName}} = "{{.IndexName}}"
    {{- end }}
  {{- end }}
{{- end }}
`

func main() {
	outPath := "./model/query"
	g := gen.NewGenerator(gen.Config{
		OutPath: outPath,
		Mode:    gen.WithDefaultQuery | gen.WithoutContext,
	})

	// generate from struct in project
	g.ApplyBasic(model.Models...)
	g.Execute()
	genConstants(outPath, model.Models...)
}

func genConstants(outPath string, models ...interface{}) {
	packageName := path.Base(outPath)
	outFile := path.Join(outPath, constantsFile)

	file, err := os.Create(outFile)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	tmpl, err := template.New("constant").Parse(constantTemplate)
	if err != nil {
		fmt.Println("Error parsing template:", err)
		return
	}

	var modelsData []map[string]interface{}
	for _, model := range models {
		modelType := reflect.TypeOf(model).Elem()
		modelName := modelType.Name()

		var fields []map[string]interface{}
		for _, field := range getFields(modelType) {
			columnName := getColumnName(field)
			indexName := getIndexName(modelName, field)

			fieldData := map[string]interface{}{
				"ModelName":  modelName,
				"FieldName":  field.Name,
				"ColumnName": columnName,
				"IndexName":  indexName,
			}
			fields = append(fields, fieldData)
		}

		modelData := map[string]interface{}{
			"ModelName": modelName,
			"Fields":    fields,
		}

		modelsData = append(modelsData, modelData)
	}

	data := map[string]interface{}{
		"PackageName": packageName,
		"Models":      modelsData,
		"ScriptName":  "/build/tools/gen_query/main.go",
	}

	err = tmpl.Execute(file, data)
	if err != nil {
		fmt.Println("Error executing template:", err)
		return
	}

	fmt.Println("constants.go file has been generated.")
}

func toSnakeCase(str string) string {
	var result []rune
	for i, v := range str {
		// If the current character is uppercase and not the first character
		// and the previous character is lowercase or not a letter
		if i > 0 && unicode.IsUpper(v) {
			// If the previous character is lowercase or the start of the string, add an underscore
			if unicode.IsLower(rune(str[i-1])) || !unicode.IsLetter(rune(str[i-1])) {
				result = append(result, '_')
			}
		}
		result = append(result, unicode.ToLower(v))
	}
	return string(result)
}

func getColumnName(field reflect.StructField) string {
	tag := field.Tag.Get("gorm")
	if tag != "" {
		for _, part := range strings.Split(tag, ";") {
			if strings.HasPrefix(part, "column:") {
				return strings.TrimPrefix(part, "column:")
			}
		}
	}
	return toSnakeCase(field.Name)
}

// GetIndexes extracts all indexes (unique, normal, fulltext, spatial)
// from a GORM tag.
func getIndexName(modelName string, field reflect.StructField) string {
	gormTag := field.Tag.Get("gorm")
	if gormTag == "" {
		return ""
	}

	for _, part := range strings.Split(gormTag, ";") {
		if strings.HasPrefix(part, "uniqueIndex") || strings.HasPrefix(part, "index") {
			kv := strings.Split(part, ":")
			if len(kv) == 2 {
				return kv[1]
			}
			return fmt.Sprintf("idx_%s_%s", toSnakeCase(modelName), toSnakeCase(field.Name))
		}
	}
	return ""
}

// Get all fields including those from embedded structs like gorm.Model
func getFields(modelType reflect.Type) []reflect.StructField {
	var fields []reflect.StructField

	for i := 0; i < modelType.NumField(); i++ {
		field := modelType.Field(i)
		if field.Anonymous {
			embeddedType := field.Type
			for j := 0; j < embeddedType.NumField(); j++ {
				fields = append(fields, embeddedType.Field(j))
			}
		} else {
			fields = append(fields, field)
		}
	}

	return fields
}
